/* Generated by Together */

package lehrer;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import java.util.TreeSet;

import javax.swing.JOptionPane;

import takter.Takter;
import tools.Logbuch;
import estKonstanten.ESTEigenschaften;

/**
 * Alle Lehrer werden hier in einer ArrayList verwaltet. Zusätzlich wird ein
 * Lehrer als momentan Aktueller markiert.
 * <p>
 * Version 2.2
 * <p>
 * August 2007
 * 
 * @author Admin
 */
public class Kollegium implements Serializable {

	private static final long serialVersionUID = 3689916184317210677L;
	private ArrayList<Lehrer> meineLehrer;
	private int actNumber;

	/**
	 * Aus der angegebenen Datei (per Name übergeben) werden die Daten der
	 * Lehrer gelesen. Die Datei enthält pro Lehrer eine Zeile der Form<br>
	 * Name, Kürzel, Buchstabe<br>
	 * Dabei ist der Buchstabe "m" oder "w"
	 * 
	 * @param dateiname
	 * 
	 * 
	 */

	public Kollegium(String dateiname) {

		Logbuch l = Logbuch.getLogbuch();
		l.log("LehrerContructor", 10);
		TreeSet<Lehrer> ts = new TreeSet<Lehrer>();
		String zeile;
		String name = "";
		String kuerzel = "";
		String raum = "";
		String sexString = "";
		boolean sex = true;
		BufferedReader eingabeDatei;
		try {
			eingabeDatei = new BufferedReader(new InputStreamReader(
					new FileInputStream(dateiname), "UTF-8"));
			// eingabeDatei = new BufferedReader(new FileReader(dateiname));
		} catch (IOException e) {
			eingabeDatei = null;
			l.log("Datei nicht gefunden!", 0);
		}

		try {
			zeile = eingabeDatei.readLine().trim();
			zeile = zeile.substring(1); // Wieso????????????????
			l.log("Z:<" + zeile + ">", 10);
		} catch (IOException e) {
			zeile = null;
			l.log("Keine Zeile (1)", 0);
		}

		try {

			while (eingabeDatei != null && zeile != null) {
				StringTokenizer tokens = new StringTokenizer(zeile, ",;");
				try {
					name = tokens.nextToken().trim();
					raum = "";
					kuerzel = tokens.nextToken().trim();
					sexString = tokens.nextToken().trim();
					sex = sexString.equals("m");
				} catch (NoSuchElementException e) {
					l.log("Einlesefehler bei Lehrer: " + name, 0);
					JOptionPane.showMessageDialog(null,
							"Einlesefehler bei Lehrer: " + name, "Achtung",
							JOptionPane.ERROR_MESSAGE);
				}
				l.log("Name = " + name + " Kuerzel = " + kuerzel + " Sex = "
						+ sexString + " Raum = " + raum, 5);
				ts.add(new Lehrer(name, kuerzel, sex, raum));
				try {
					zeile = eingabeDatei.readLine();
				} catch (IOException e) {
					zeile = null;
					l.log("Keine Zeile (2)", 0);
				}
			}// while

			this.meineLehrer = new ArrayList<Lehrer>();
			Iterator<Lehrer> it = ts.iterator();
			while (it.hasNext()) {
				Lehrer le = it.next();
				this.meineLehrer.add(le);
			}

			this.actNumber = 0;
			eingabeDatei.close();
		} catch (IOException e) {
			l.log("Einlesefehler in Lehrer-Textdatei " + dateiname, 0);
		}
	}

	/**
	 * Der momentan markierte Lehrer wird ausgeliefert.
	 * 
	 * @return Lehrer Der aktuelle Lehrer
	 */
	public Lehrer actLehrer() {
		return (this.meineLehrer.get(this.actNumber));
	}

	/**
	 * Liefert den Lehrer mit der angegebenen Nummer
	 * 
	 * @param nummer
	 * @return Lehrer mit der Nummer.
	 */
	public Lehrer getLehrer(int nummer) {
		if (nummer >= 0 && nummer < this.meineLehrer.size()) {
			return this.meineLehrer.get(nummer);
		} else {
			return null;
		}
	}

	/**
	 * Die Nummer des momentan markierten Lehrers wird ausgeliefert.
	 * 
	 * @return int Nummer des akt. Lehrers
	 */
	public int actNumberLehrer() {
		return (this.actNumber);
	}

	/**
	 * Die Marke wird - sofern nicht am Ende - weitergeschoben, so dass der
	 * folgende Lehrer markiert ist.
	 */
	public void inc() {
		if (this.actNumber < this.meineLehrer.size() - 1) {
			this.actNumber = this.actNumber + 1;
		}
	}

	public void reset() {
		this.actNumber = 0;
	}

	public void setLehrer(int lnr) {
		if (lnr >= 0 && lnr < this.anzahlLehrer()) {
			this.actNumber = lnr;
		}
	}

	public void loescheLehrer(int i) {
		this.meineLehrer.remove(i);
		this.reset();
	}

	/**
	 * Die Marke wird - sofern nicht am Anfang - zurückgeschoben, so dass der
	 * vorherige Lehrer markiert ist.
	 */
	public void dec() {
		if (this.actNumber > 0) {
			this.actNumber = this.actNumber - 1;
		}
	}

	/**
	 * Gibt die Anzahl der momentan verwalteten Lehrer an.
	 * 
	 * @return int Anzahl der Lehrer
	 * 
	 */
	public int anzahlLehrer() {
		return this.meineLehrer.size();
	}

	/**
	 * Trägt den angegebenen Fall bei dem angegebenen Lehrer im angegebenen Takt
	 * ein.
	 * 
	 * @param lnr
	 * @param tnr
	 * @param fnr
	 */
	public void trageFallEin(int lnr, int tnr, int fnr) {
		Lehrer l = this.getLehrer(lnr);
		if (l != null) {
			l.belege(tnr, fnr);
		}
	}

	/**
	 * Trägt bei dem angegebenen Lehrer im angegebenen Takt ein BEFREIT ein.
	 * 
	 * @param lnr
	 * @param tnr
	 */
	public void trageFallAus(int lnr, int tnr) {
		Lehrer l = this.getLehrer(lnr);
		if (l != null) {
			l.setBelegbar(tnr);
		}
	}

	public ArrayList<String> getTermine(int lnr, int von, int bis) {
		return this.getLehrer(lnr).getTerminListe(von, bis);
	}

	public ArrayList<String> getTermine(int lnr) {
		return getTermine(lnr, 0, ESTEigenschaften.getAnzahlTakte() - 1);
	}

	public String freieZeiten(int lnr) {
		Takter t = new Takter();
		boolean[] belegt = this.getLehrer(lnr).freieZeiten();
		return t.takt2String(belegt);
	}

	public String besuchbareZeiten(int lnr) {
		Takter t = new Takter();
		boolean[] belegt = this.getLehrer(lnr).besuchbareZeiten();
		return t.takt2String(belegt);
	}

	public String belegbareZeiten(int lnr) {
		Takter t = new Takter();
		boolean[] belegt = this.getLehrer(lnr).belegbareZeiten();
		return t.takt2String(belegt);
	}

	public String anwesendeZeiten(int lnr) {
		Takter t = new Takter();
		boolean[] belegt = this.getLehrer(lnr).anwesendeZeiten();
		return t.takt2String(belegt);
	}

	public void makeAllTeachersAlwaysFree() {
		Iterator<Lehrer> it = this.meineLehrer.iterator();
		while (it.hasNext()) {
			Lehrer hier = it.next();
			for (int i = 0; i < ESTEigenschaften.getAnzahlTakte(); i++) {
				hier.setBelegbar(i);
			}
		}
	}
}
